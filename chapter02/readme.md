# Chapter 02

# 리팩터링 원칙

## 2.1 리팩터링 정의

- 소프트웨어의 '겉보기 동작'은 유지한채, 코드를 이해하기 쉽고 수정하기 쉽도록 재구성
- 리팩터링은 재구성의 특수한 경우

## 2.2 기능추가 vs 리팩터링

- 두 가지 작업은 완전히 분리되어 진행되어야한다.

## 2.3 Why? 리팩터링을 하는 이유

- 아키텍쳐를 바라보는 시각이 좋아진다.
- 소프트웨어를 이해하기 쉬워진다.
- 버그를 쉽게 찾을 수 있다.
  <br>
  또한 앞서 말한것들로 인해 프로그래밍 속도를 높일 수 있다.

## 2.4 When? 리팩터링은 언제 해야할까

- 즉, '리팩터링'을 생각하게 되는 상황을 생각해보자
- 반복이 3회 될때
- 기능을 추가하기 직전
  - 기능을 쉽게 추가할 수 있게 리팩터링
- 코드를 파악할 때
  - 코드를 이해하기 쉽게 리팩터링
- 코드가 비효율적으로 보일 때
  - 쓰레기 줍기식 리팩터링
- 코드 리뷰를 할 때

몇주에 걸쳐 조금씩, 수시로 하는것이 더 효율적이다.
<br>
처음부터 새로 쓰는게 나을 때, 내부 로직을 알 수 없을 때는 하지 않는다.

## 2.5 리팩터링 시 고려할 문제
- 새 기능 개발 속도 저하
  - 리팩터링은 궁극적으로 개발속도를 높이는 것이다. 경제적인 이유가 가장 크다.
- 코드 소유권
  - 누구나 코드를 수정할 수 있게 만들어야 함수를 추출하고 이름을 바꾸는 리팩터링을 할 때 유리하다.
- 브랜치
  - 기능별 브랜치의 병합 주기를 짧게하는것이 좋다. 코드 소유권 문제와 비슷한 이유이다.
- 테스팅
  - 리팩터링 시 테스트 코드의 중요성 강조.
- 레거시 코드
  - 레거시 코드를 파악할 때 리팩터링이 많이 도움된다.
- 데이터베이스
  - 버전 업을 하면서 마이그레이션 스크립트에 스키마 변경사항을 포함시켜서 리팩터링을 한다.
  - 이 과정은 이전에 말한것과 달리 작은 단계들로 나눠서 수행하는것이 좋다.
## 2.6 리팩터링과 아키텍쳐
- 다양한 예상변수에 따른 매개변수를 추가하는 등의 유연성 매커니즘을 활용한다.(물론 당장에는 함수가 복잡해지는 비용을 지불해야한다.)
- 리팩터링은 아키텍쳐 변경 요구에 유연하게 대처하게 해준다.

## 2.7 리팩터링과 소프트웨어 개발 프로세스
TDD (Test-Driven Development) : 
테스트 주도 개발
## 2.8 리팩터링과 성능
리팩터링을 하면 대게 성능은 느려지기 마련이다.
<br>
다음 3가지 방법으로 성능을 높일 수 있다.
- 하드 리얼 시스템에서의 시간 예산 분배
- 프로그램에 대한 지속적인 관심
- 일단 코드를 작성하고 분석하는 시점에서 코드 리팩터링에 더욱 집중한다.
